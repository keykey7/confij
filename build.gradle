buildscript {
	repositories {
		mavenLocal()
		mavenCentral()
	}
}

plugins {
	id 'version-catalog'
	id 'test-report-aggregation'
	id 'jacoco-report-aggregation'
	id 'org.ajoberstar.reckon' version '0.16.1'
	id 'org.sonarqube' version '3.3'
	id 'com.github.ben-manes.versions' version '0.42.0'
	id 'org.asciidoctor.jvm.convert' version '3.3.2' apply false
	id 'com.github.johnrengelman.shadow' version '7.1.2' apply false
	id 'io.github.gradle-nexus.publish-plugin' version '1.1.0' apply false
}

tasks.named("dependencyUpdates").configure {
	def isNonStable = { String version ->
		def stableKeyword = ['RELEASE', 'FINAL', 'GA'].any { version.toUpperCase().contains(it) }
		def regex = /^[0-9,.v-]+(-r)?$/
		return !stableKeyword && !(version ==~ regex)
	}
	rejectVersionIf {
		isNonStable(it.candidate.version)
	}
}

reckon {
	scopeFromProp()
	snapshotFromProp()
}
if (System.getenv('CI') == null) {
	version = "0.0.0-SNAPSHOT"
}
task version {
	doLast {
		if (project.findProperty('reckon.stage')) {
			println "to tag and release a new version '${version}' use:"
			println "git tag -a '${version}' -m '${version}' && git push origin '${version}'"
		} else {
			println "current version is '${version}', to figure out the next version run:"
			println "CI=true ./gradlew version -Preckon.stage=final -Preckon.scope=[major,minor,patch]"
		}
	}
}
reckonTagCreate.dependsOn "build"

allprojects {
	repositories {
		mavenCentral()
	}
	group 'ch.kk7'
	version rootProject.version
}

// java defaults
subprojects {
	apply plugin: 'java-library'
	apply plugin: 'jacoco'
	java {
		toolchain {
			languageVersion = JavaLanguageVersion.of(8)
		}
		consistentResolution {
			useCompileClasspathVersions()
		}
		withSourcesJar()
		withJavadocJar()
	}
	[11, 16].forEach(jv -> {
		def testJava = tasks.register("testJava${jv}", Test) {
			javaLauncher = javaToolchains.launcherFor {
				languageVersion = JavaLanguageVersion.of(jv)
			}
			shouldRunAfter 'test'
		}
		tasks.check.configure {
			dependsOn testJava
		}
	})
	tasks.withType(JavaCompile) {
		options.incremental = true
	}
	tasks.withType(AbstractArchiveTask) {
		preserveFileTimestamps = false
		reproducibleFileOrder = true
	}
	javadoc.options.addStringOption('Xdoclint:none', '-quiet')
	configurations {
		testOutput.extendsFrom testImplementation // reuse tests directly
		compileOnly.extendsFrom annotationProcessor
		testCompileOnly.extendsFrom compileOnly
		testAnnotationProcessor.extendsFrom annotationProcessor
	}
	gradle.taskGraph.whenReady { taskGraph -> // workaround for https://github.com/ben-manes/gradle-versions-plugin/issues/592
		if(!taskGraph.hasTask(":dependencyUpdates")) {
			configurations.all {
				resolutionStrategy {
					failOnVersionConflict()
					failOnNonReproducibleResolution()
				}
			}
		}
	}
	dependencies {
		annotationProcessor libs.autoservice
		annotationProcessor libs.lombok

		testImplementation libs.junit.params
		testImplementation libs.junit.engine
		testImplementation libs.assertj
		testImplementation libs.systemlambda
		testImplementation libs.awaitility

		testRuntimeOnly libs.logback.classic
	}
	tasks.withType(Test) {
		useJUnitPlatform() // junit5 support
		if (System.getenv().containsKey("CI")) {
			testLogging {
				events "failed"
				exceptionFormat "full"
			}
		}
	}
}

// coverage
dependencies {
	jacocoAggregation subprojects
}
reporting {
	reports {
		testCodeCoverageReport(JacocoCoverageReport) {
			testType = TestSuiteType.UNIT_TEST
		}
	}
}
sonarqube {
	properties {
		property 'sonar.host.url', 'https://sonarcloud.io'
		property 'sonar.organization', 'keykey7-github'
		property 'sonar.login', System.getenv('SONAR_TOKEN')
		property 'sonar.coverage.jacoco.xmlReportPaths', tasks.testCodeCoverageReport.reports.xml.outputLocation.get()
	}
}
// disable sonar analysis without secret (since secrets aren't availabe in PRs from forks)
tasks.sonarqube.enabled System.getenv('SONAR_TOKEN') != null
tasks.sonarqube.dependsOn tasks.testCodeCoverageReport

// releases
def isRemotePublish = System.getenv('CI') != null && System.getenv('SONATYPE_USERNAME') != null
if (isRemotePublish) {
	logger.lifecycle("remote publishing is enabled")
	apply plugin: 'io.github.gradle-nexus.publish-plugin'
	nexusPublishing {
		repositories {
			sonatype {
				username = System.getenv('SONATYPE_USERNAME')
				password = System.getenv('SONATYPE_PASSWORD')
			}
		}
	}
}
subprojects {
	if (sourceSets.main.allSource.isEmpty()) {
		return // excluding test-only subprojects
	}
	apply plugin: 'maven-publish'
	publishing {
		publications {
			java(MavenPublication) {
				from components.java
				pom {
					def githubUrl = "https://github.com/keykey7/confij"
					name = project.name
					description = "A type-safe, strongly defined Java configuration library"
					url = githubUrl
					licenses {
						license {
							name = 'The Apache License, Version 2.0'
							url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
						}
					}
					scm {
						connection = "scm:git:${githubUrl}.git"
						developerConnection = "scm:git:${githubUrl}.git"
						url = githubUrl
					}
					developers {
						developer {
							id = 'keykey7'
							name = 'keykey7'
							email = 'noreply@kk7.ch'
						}
					}
				}
			}
		}
	}
	if (isRemotePublish) {
		apply plugin: 'signing'
		signing {
			def signingKey = System.getenv('SONATYPE_SIGNKEY')
			def signingPassword = System.getenv('SONATYPE_SIGNPASS')
			useInMemoryPgpKeys(signingKey, signingPassword)
			sign publishing.publications.java
		}
	}
}
