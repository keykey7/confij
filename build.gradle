buildscript {
	repositories {
		mavenLocal()
		jcenter()
	}
}

plugins {
	id 'org.ajoberstar.reckon' version '0.12.0'
	id 'com.github.ben-manes.versions' version '0.29.0' // task: dependencyUpdates
	id 'org.sonarqube' version '3.0'
	id 'org.asciidoctor.jvm.convert' version '3.2.0' apply false
	id 'com.jfrog.bintray' version '1.8.5' apply false
	id 'com.github.johnrengelman.shadow' version '6.0.0' apply false
}

reckon {
	scopeFromProp()
	stageFromProp('rc', 'final')
}
if (System.getenv('CI') == null) {
	project.version = "0.0.0-SNAPSHOT"
}
task version {
	doLast {
		if (project.findProperty('reckon.stage')) {
			println "to tag and release a new version use:"
			println "git tag -a '${project.version}' -m '${project.version}' && git push origin '${project.version}'"
		} else {
			println "to figure out the next version run:"
			println "CI=true ./gradlew version -Preckon.scope=[major,minor,patch] -Preckon.stage=[rc,final]"
		}
	}
}
reckonTagCreate.dependsOn "build"

allprojects {
	repositories {
		jcenter()
	}
	apply plugin: 'idea'
	group 'ch.kk7'
	version rootProject.version
}

dependencyUpdates.resolutionStrategy {
	componentSelection { rules ->
		rules.all { ComponentSelection selection ->
			boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm', 'preview', 'b', 'ea'].any { qualifier ->
				selection.candidate.version ==~ /(?i).*[.-]$qualifier[.\d-+]*/
			}
			if (rejected) {
				selection.reject('Release candidate')
			}
		}
	}
}

subprojects {
	apply plugin: 'java-library'

	java {
		sourceCompatibility = JavaVersion.VERSION_1_8
		targetCompatibility = JavaVersion.VERSION_1_8
		withSourcesJar()
	}

	tasks.withType(JavaCompile) {
		options.incremental = true
	}

	tasks.withType(AbstractArchiveTask) {
		preserveFileTimestamps = false
		reproducibleFileOrder = true
	}

	configurations.runtime {
		resolutionStrategy {
			failOnVersionConflict()
		}
	}

	configurations.all {
		resolutionStrategy {
			failOnNonReproducibleResolution()
		}
	}

	dependencies {
		def autoServiceVersion = "1.0-rc7"
		compileOnly "com.google.auto.service:auto-service:${autoServiceVersion}"
		annotationProcessor "com.google.auto.service:auto-service:${autoServiceVersion}"
		testCompileOnly "com.google.auto.service:auto-service:${autoServiceVersion}"
		testAnnotationProcessor "com.google.auto.service:auto-service:${autoServiceVersion}"

		def lombokVersion = "1.18.12"
		compileOnly "org.projectlombok:lombok:${lombokVersion}"
		annotationProcessor "org.projectlombok:lombok:${lombokVersion}"
		testCompileOnly "org.projectlombok:lombok:${lombokVersion}"
		testAnnotationProcessor "org.projectlombok:lombok:${lombokVersion}"

		def junitVersion = '5.6.2'
		testImplementation "org.junit.jupiter:junit-jupiter-params:${junitVersion}"
		testImplementation "org.junit.jupiter:junit-jupiter-engine:${junitVersion}"
		testImplementation "org.assertj:assertj-core:3.16.1"
		testImplementation "com.github.stefanbirkner:system-lambda:1.1.0"
		testImplementation "org.awaitility:awaitility:4.0.3"

		testRuntimeOnly 'ch.qos.logback:logback-classic:1.2.3'
	}

	test {
		useJUnitPlatform() // junit5 support
		if (System.getenv('CI') != null) {
			testLogging {
				events "passed", "skipped", "failed"
				exceptionFormat "full"
			}
		}
	}
}

// coverage
subprojects {
	apply plugin: 'jacoco'
}

apply plugin: 'base'
apply plugin: 'jacoco'
task jacocoMerge(type: JacocoMerge) {
	subprojects.each { subproject ->
		executionData subproject.tasks.withType(Test)
	}
	doFirst {
		executionData = files(executionData.findAll { it.exists() })
	}
}

task jacocoRootReport(type: JacocoReport, group: 'verification') {
	description = 'Generates an aggregate report from all subprojects'
	dependsOn subprojects.test, jacocoMerge

	additionalSourceDirs.from(subprojects.sourceSets.main.allSource.srcDirs)
	sourceDirectories.from(subprojects.sourceSets.main.allSource.srcDirs)
	classDirectories.from(subprojects.sourceSets.main.output)
	executionData jacocoMerge.destinationFile
	reports.xml.enabled true
	doLast {
		logger.lifecycle("report at: " + reports.html.entryPoint.toURI())
	}
}

allprojects {
	sonarqube {
		properties {
			property 'sonar.host.url', 'https://sonarcloud.io'
			property 'sonar.organization', 'keykey7-github'
			property 'sonar.login', System.getenv('SONAR_TOKEN')
			property 'sonar.coverage.jacoco.xmlReportPaths', jacocoRootReport.reports.xml.destination
		}
	}
}
// disable sonar analysis without secret (since secrets aren't availabe in PRs from forks)
project.tasks['sonarqube'].enabled System.getenv('SONAR_TOKEN') != null
project.tasks['sonarqube'].dependsOn jacocoRootReport

// releases
subprojects {
	if (sourceSets.main.allSource.isEmpty()) {
		return // excluding test-only subprojects
	}

	apply plugin: 'maven-publish'
	ext {
		confijDescription = "A type-safe, strongly defined Java configuration library"
		confijGithub = "keykey7/confij"
		confijUrl = "https://github.com/${confijGithub}"
	}

	publishing {
		publications {
			java(MavenPublication) {
				from components.java
				pom {
					name = project.name
					description = project.confijDescription
					url = "" + project.confijUrl
					licenses {
						license {
							name = 'The Apache License, Version 2.0'
							url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
						}
					}
				}
			}
		}
	}

	// bintray
	apply plugin: 'com.jfrog.bintray'
	def isReleaseBuild = project.version.toString().matches("[0-9.]+") // no "rc" or "snapshot"
	bintray {
		user = 'kk7'
		key = System.getenv('BINTRAY_TOKEN')
		publications = project.publishing.publications.collect{ it.name }
		publish = isReleaseBuild

		pkg {
			repo = isReleaseBuild ? 'mvn-release' : 'mvn-snapshot'
			name = project.name
			desc = project.confijDescription

			websiteUrl = project.confijUrl
			vcsUrl = project.confijUrl
			githubRepo = project.confijGithub
			licenses = ['Apache-2.0']
			labels = ['configuration']
			version {
				name = project.version
				released = new Date()
				mavenCentralSync {
					sync = false
				}
			}
		}
	}

	bintrayUpload {
		dependsOn publishToMavenLocal
		doFirst {
			Objects.requireNonNull(apiKey, 'missing bintray token')
		}
	}
	publish.dependsOn bintrayUpload
}
