= Configuration Sources
:src: ../../test/java/ch/kk7/confij/docs/Source.java
:resources: ../../test/resources
:home: ../../test/home

== Source Pipelines
ConfiJ sources are loaded one after the other.
Each consecutive source overrides attributes of the previous ones.
Typically this is useful to load a set of default values first,
then continue with application specifics and environment specific values
getting more and more detailed.
Source types can be freely mixed, meaning you can load from classpath, then from a remote file, then from envionment variables and so on.

.Merge multiple configuration files across all formats
====
[source]
----
include::{src}[tag=interface]

include::{src}[tag=pipedsource]
----
====
<1> <<format-default,Default values>> are always loaded first.
<2> then override with a file from the classpath root.
[source]
include::{resources}/generic.properties[]
<3> then override with a file on disk
[source]
include::{home}/server.properties[]
<4> then override with system properties prefixed by `app`
[source]
-Dapp.line=3

This will end up with the final configuration:
----
include::{resources}/pipedsource.txt[]
----

Validation generally only applies to the final configuration.
It is allowed to have incomplete configurations while there are still more configuration sources to load.
In the example above, `name` was undefined until round 3.

== Default Values [[format-default]]

Configuration default can be defined directly in your configuration interface using the `@Default` annotation.
For more complex scenarios where the default value is not easily stingifyable,
use a `default` method.

.Default configuration values as annotations
====
[source]
----
include::{src}[tag=defaults]
----
====

== The AnySource [[anysource]]

The `AnySource` simply takes a URI-string and determines resource location and type based on it.
It is the most compact form to specify a source unless you require special settings.

.Load from multiple sources of dynamic type and location
====
[source]
----
include::{src}[tag=anysource]
----
====

Variable substitutions are supported anywhere in the template string (see <<variables>>).
They take into account the previously loaded configuration keys.
Replacement keys are always absolute (relative to the configuration root).

Most commonly the resource location (file, classpath,...) is detected based on the URI scheme (see <<resource-locations>>).
The configuration format (yaml, json,...) is detected based on the ending.

== Sources and Formats

=== Resource Providers [[resource-locations]]

Configuration sources that can load from a file can usually load from other input streams as well.
For those, the source location and source format can be combined freely.

<<anysource>> detects the location based on the scheme:

- `file:` - is the default scheme and loads from the local Filesystem
- `classpath:` - load from classpath on the default classloader
- `http:` or any other registered URL format

Register custom resource providers using a <<serviceloader>> for `ch.kk7.confij.source.file.resource.ConfijResourceProvider`.

=== YAML Format

NOTE: YAML format requires the `{group}:confij-yaml` maven artifact.

YAML is a recommended configuration source format since it maps nicely on a tree-structure.
Collection types can be represented as lists or as maps with numerical keys.

YAML can be loaded from all the <<resource-locations>>.
The `AnySource` expects a case-insensitive file ending of `.yaml` or `.yml`.

.Load from multiple sources of dynamic type and location
====
[source]
----
include::{src}[tag=yaml-interface]
----
[source,yaml]
----
include::{home}/complex.yaml[]
----
====

If the YAML source file contain multi-docs, they are loaded in order.
Internally all values are reduced to Maps of Maps or Strings.

=== Properties Format

Java properties files are part of the `{group}:confij-core` due to not having any 3rd party dependencies,
but are otherwise not recommended, since it is a flat key-value format.

Properties files can be loaded from all the <<resource-locations>>.
The `AnySource` expects a case-insensitive file ending of `.properties`.

.Nested configuration loading from properties file
====
[source]
----
include::{src}[tag=nestedinterface]
----
----
include::{home}/nested.properties[]
----
====

<1> Per default, nested configuration keys are separated with a dot form each other.
<2> Collection types simply require numerical keys (starting at 0).
<3> Map types can use any key excluding the delimiter.

=== Environment Variables Format

=== System Properties Format

=== Logical Sources

== ConfiJ's ServiceLoaders [[serviceloader]]

ConfiJ allows to utilize Java's https://docs.oracle.com/javase/8/docs/api/?java/util/ServiceLoader.html[ServiceLoader]
mechanism to register additional services like source formats or validators.
All you have to do is to add the file with the service-interface name to META-INF/services.
In this service file you list the fully qualified classnames of your constraint validator classes (one per line).

.Custom Resource Provider as ServiceLoader
====
[source]
----
include::{src}[tag=resourceprovider-service]

include::{src}[tag=resourceprovider]
----
====

To change the priority of a service loader instance implement the `ServiceLoaderPriority`.

.Custom Resource Provider as ServiceLoader with lowered priority
====
[source]
----
include::{src}[tag=resourceprovider-service-ignored]
----
====
